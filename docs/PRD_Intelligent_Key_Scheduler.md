### **产品需求文档 (PRD): 智能密钥调度器 (Intelligent Key Scheduler)**

**1. 背景与目标**

*   **1.1 背景:**
    在使用 Gemini API 时，我们依赖于一组 API 密钥池。当流量增加或部分密钥因配额耗尽、权限问题或服务临时故障而失效时，系统会频繁出现请求失败。手动管理和轮换密钥效率低下，且响应不及时，严重影响了服务的稳定性和用户体验。
*   **1.2 目标:**
    为了解决上述问题，我们设计并实现了“智能密钥调度器”。其核心目标是自动化地管理 API 密钥生命周期，智能地处理各类异常，确保 API 请求的高可用性和成功率，并最大限度地利用密钥池资源。

**2. 用户故事 (User Stories)**

*   **作为系统管理员:** 我希望系统能够自动检测并弃用那些无效或权限错误的密钥，这样我就不必手动排查和移除它们。
*   **作为系统管理员:** 我希望系统在遇到服务临时抖动时能够自动重试，并在持续失败后暂时“雪藏”有问题的密钥，而不是直接将其废弃，以应对服务恢复后的情况。
*   **作为最终用户:** 我希望在使用服务时感受不到后端密钥切换或临时故障带来的影响，获得稳定、流畅的体验。

**3. 功能需求 (Functional Requirements)**

*   **3.1 核心调度逻辑:**
    *   系统维护一个 API 密钥池，并采用轮询 (Round-Robin) 策略来分配密钥，确保负载均衡。
*   **3.2 状态持久化:**
    *   所有密钥的状态（如：可用、冷却中、失效）以及其最后使用时间、配额信息等，都必须被持久化存储（例如，存储在本地文件中）。
    *   当服务重启时，系统必须能够从持久化存储中加载密钥的最新状态，避免了冷启动时对已失效密钥的无效尝试。
*   **3.3 自动化配额重置:**
    *   系统应能根据 Gemini API 的配额刷新周期（例如，每分钟），自动将因配额耗尽而处于“冷却中”状态的密钥重新标记为“可用”。
*   **3.4 智能异常处理机制:**
    *   **3.4.1 客户端错误 (40x Errors):**
        *   当系统使用某个密钥请求 API 并收到 `40x` 类的客户端错误（如 `400 Bad Request`, `403 Forbidden`）时，系统应判定该密钥为永久性失效。
        *   判定逻辑包括但不限于：密钥格式不正确、账户权限不足、违反使用策略等。
        *   **处理动作:** 系统将自动把该密钥的状态更新为“失效”，并将其从有效的轮询池中永久移除，确保后续请求不再使用它。
    *   **3.4.2 服务器端错误 (50x Errors) 与熔断机制:**
        *   当系统使用某个密钥请求 API 并收到 `50x` 类的服务器端错误（如 `500 Internal Server Error`, `503 Service Unavailable`）时，系统应判定为临时性、可恢复的故障。
        *   **处理动作 (重试与熔断):**
            1.  **有限重试:** 系统将针对当前请求，使用同一个密钥进行有限次数的重试（例如，最多重试2次）。
            2.  **临时挂起 (冷却):** 如果连续重试均失败，系统会将该密钥的状态更新为“冷却中”，并将其暂时从轮询池中移出。
            3.  **自动恢复:** 进入“冷却中”状态的密钥将在设定的冷却时间（例如，5分钟）后，被系统自动恢复为“可用”状态，重新加入轮- 询池。

**4. 验收标准 (Acceptance Criteria)**

*   **AC-1:** 系统能够成功从持久化文件中加载密钥池并提供服务。
*   **AC-2:** 当一个密钥返回 `403` 错误后，该密钥被标记为“失效”，并且后续的 API 请求日志中不再出现此密钥。
*   **AC-3:** 当一个密钥连续返回3次 `500` 错误后，该密钥被标记为“冷却中”，在5分钟内不再被使用。5分钟后，该密钥被重新用于发送请求。
*   **AC-4:** 在高并发请求下，密钥池中的密钥被均匀地使用。