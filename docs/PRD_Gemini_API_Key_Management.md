# **产品需求文档 (PRD): KeyManager 服务模块**

| **版本** | **日期**       | **作者** | **变更描述**     |
| :------- | :------------- | :------- | :--------------- |
| 2.0      | 2025-09-25 | AI产品经理 | **重大修订**: 根据 `src/key_manager.js` 的实际实现重写PRD，确保与代码完全同步。 |
| 1.0      | 2025-09-25 | AI产品经理 | 初始版本         |

## 1. 背景与目标

### 1.1 问题陈述
在应用程序对 Gemini API 的高频调用场景下，单个 API 密钥很容易达到其速率或配额限制，从而导致服务中断。为了提高系统的健壮性和可用性，需要一个能够在多个密钥之间自动轮换和故障切换的机制。

### 1.2 产品目标
`KeyManager` 模块旨在为应用程序提供一个可靠、高效的 API 密钥池管理方案。其核心目标是：
*   **提高可用性**: 通过轮换使用密钥池中的多个密钥，避免因单个密钥配额耗尽而导致的服务中断。
*   **智能故障处理**: 能够将暂时不可用（如配额耗尽、服务器错误）的密钥自动移出轮换池。
*   **状态恢复**: 提供一种机制，能够定期重置所有密钥的配额状态，使其可以被重新尝试使用。
*   **简化集成**: 为上层服务提供一个简单的接口来获取可用密钥，封装密钥管理的复杂逻辑。

## 2. 目标用户

本模块的直接“用户”是**应用程序内部需要调用 Gemini API 的其他业务模块**（以下简称“客户端模块”）。

## 3. 用户故事 (User Stories)

| 编号 | 作为 (As a) | 我想要 (I want to) | 以便 (So that) | 优先级 |
| :--- | :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----- |
| US-01| 客户端模块  | 从 `KeyManager` 获取一个当前可用的 API 密钥                  | 我可以成功地发起一次 API 调用                                | **核心** |
| US-02| 客户端模块  | 在 API 调用因“配额耗尽”失败后，将该密钥标记为“配额已耗尽” | `KeyManager` 在后续的轮换中可以跳过这个密钥，避免重复失败    | **核心** |
| US-03| 客户端模块  | 在 API 调用因“服务器错误”失败后，将该密钥标记为“服务异常”   | `KeyManager` 可以追踪到哪些密钥可能暂时有问题                | **高**   |
| US-04| 客户端模块  | 在一次 API 调用成功后，通知 `KeyManager`                     | 可以清除该密钥的“服务异常”标记，确认其恢复正常             | **高**   |
| US-05| 系统（定时任务） | 能够定期重置所有密钥的“配额耗尽”状态                 | 让之前耗尽的密钥有机会被重新尝试，适应配额的周期性刷新       | **核心** |
| US-06| 应用程序    | 在启动时，通过环境变量传入一组密钥来初始化 `KeyManager`      | 我可以灵活地为不同部署环境配置不同的密钥池                 | **核心** |
| US-07| 开发者（测试时） | 能够手动设置或覆盖 `KeyManager` 中的密钥池                 | 我可以方便地在单元测试或集成测试中注入模拟的密钥             | **中**   |


## 4. 核心功能与公共接口 (API)

`KeyManager` 模块以一个单例类的形式提供服务，其核心功能通过以下公共方法暴露：

### 4.1 `constructor(rawKeysString: string)`
*   **描述**: 构造函数，用于初始化 `KeyManager` 实例。
*   **逻辑**:
    1.  接收一个逗号分隔的 API 密钥字符串作为输入（通常来自 `process.env.GEMINI_API_KEYS`）。
    2.  将字符串解析为密钥数组，并过滤掉空值。
    3.  为每个密钥创建一个内部状态对象，包含 `key` (字符串), `quotaExceeded` (布尔, 初始`false`), `lastUsed` (时间戳, 初始`null`), 和 `serverError` (布尔, 初始`false`)。
    4.  初始化一个 `currentKeyIndex` 用于轮换。

### 4.2 `getNextAvailableKey(): object`
*   **描述**: 获取下一个可用的 API 密钥对象。这是模块最核心的方法。
*   **逻辑**:
    1.  从密钥池中筛选出所有 `quotaExceeded` 为 `false` 的密钥，形成一个“可用密钥池”。
    2.  如果可用密钥池为空，则抛出一个 `Error`，明确告知所有密钥均已耗尽。
    3.  使用 `(this.currentKeyIndex + 1) % availableKeys.length` 算法，在可用密钥池中进行循环轮换，选择下一个密钥。
    4.  更新所选密钥的 `lastUsed` 时间戳。
    5.  返回该密钥的状态对象。

### 4.3 `markQuotaExceeded(key: string)`
*   **描述**: 将指定的密钥标记为“配额已耗尽”。
*   **逻辑**:
    1.  根据传入的 `key` 字符串查找对应的密钥对象。
    2.  如果找到，且其 `quotaExceeded` 状态尚为 `false`，则将其设置为 `true`，并记录警告日志。
    3.  如果未找到该密钥，则记录一条错误日志。

### 4.4 `markServerError(key: string)`
*   **描述**: 将指定的密钥标记为“服务器错误”。
*   **逻辑**:
    1.  根据传入的 `key` 字符串查找对应的密钥对象。
    2.  如果找到，且其 `serverError` 状态尚为 `false`，则将其设置为 `true`，并记录警告日志。
    3.  此标记用于识别可能暂时不稳定的密钥。

### 4.5 `markSuccess(key: string)`
*   **描述**: 标记指定密钥的一次成功请求。
*   **逻辑**:
    1.  根据传入的 `key` 字符串查找对应的密钥对象。
    2.  如果找到，将其 `serverError` 状态重置为 `false`。这表明一次成功的请求可以清除之前的服务器错误标记。

### 4.6 `resetAllQuotaStatus()`
*   **描述**: 将池中所有密钥的 `quotaExceeded` 状态重置为 `false`。
*   **逻辑**:
    1.  遍历整个密钥池。
    2.  将每个密钥对象的 `quotaExceeded` 属性设置为 `false`。
    3.  此方法应由一个外部的定时任务（例如，每小时）调用。

### 4.7 `setKeys(keys: Array<string>)`
*   **描述**: 覆盖或设置全新的密钥池。主要用于测试。
*   **逻辑**:
    1.  接收一个字符串数组作为新的密钥列表。
    2.  完全替换现有的 `apiKeyPool`，并为每个新密钥创建标准的内部状态对象。

## 5. 非功能性需求

| 类别 | 需求描述 |
| :--- | :------- |
| **状态管理** | `KeyManager` 的所有状态都保存在内存中。应用程序重启后，所有密钥的状态（如 `quotaExceeded`）都将重置为初始值。 |
| **配置** | 密钥池通过环境变量 `GEMINI_API_KEYS` 进行配置，多个密钥之间用逗号分隔。 |
| **错误处理** | 当所有可用密钥都因配额耗尽而被标记时，`getNextAvailableKey()` 方法必须抛出一个明确的 `Error`。 |
| **日志** | 模块在初始化、标记密钥状态变更和重置配额时，应输出有意义的控制台日志，以方便调试和监控。 |

## 6. 验收标准 (Acceptance Criteria)

### 针对 `getNextAvailableKey`
1.  **Given** `KeyManager` 初始化了3个密钥 ["A", "B", "C"]
2.  **When** 连续调用 `getNextAvailableKey()` 4次
3.  **Then** 应依次返回密钥对象 A, B, C, A。

### 针对 `markQuotaExceeded`
1.  **Given** `KeyManager` 初始化了2个密钥 ["A", "B"]
2.  **When** 调用 `markQuotaExceeded("A")`
3.  **And** 之后调用 `getNextAvailableKey()`
4.  **Then** 应该返回密钥对象 B。
5.  **And** 再次调用 `getNextAvailableKey()`
6.  **Then** 应该继续返回密钥对象 B。

### 针对 `resetAllQuotaStatus`
1.  **Given** `KeyManager` 的所有密钥都被标记为 `quotaExceeded`
2.  **When** 调用 `resetAllQuotaStatus()`
3.  **And** 之后调用 `getNextAvailableKey()`
4.  **Then** 应该能成功返回一个密钥对象。

### 针对 全都耗尽 的情况
1.  **Given** `KeyManager` 的所有密钥都被标记为 `quotaExceeded`
2.  **When** 调用 `getNextAvailableKey()`
3.  **Then** 必须抛出一个 `Error`。
